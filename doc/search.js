window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "outlier_detection", "modulename": "outlier_detection", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.base", "modulename": "outlier_detection.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.base.Detection", "modulename": "outlier_detection.base", "qualname": "Detection", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "outlier_detection.base.Detection.outliers", "modulename": "outlier_detection.base", "qualname": "Detection.outliers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": pandas.core.series.Series"}, {"fullname": "outlier_detection.base.Detection.without_outliers", "modulename": "outlier_detection.base", "qualname": "Detection.without_outliers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": pandas.core.series.Series"}, {"fullname": "outlier_detection.base.Detection.diagram", "modulename": "outlier_detection.base", "qualname": "Detection.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.base.DetectionFullDataFrame", "modulename": "outlier_detection.base", "qualname": "DetectionFullDataFrame", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "Detection"}, {"fullname": "outlier_detection.base.DetectionFullDataFrame.diagram", "modulename": "outlier_detection.base", "qualname": "DetectionFullDataFrame.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.base.DetectionFullDataFrame.outliers", "modulename": "outlier_detection.base", "qualname": "DetectionFullDataFrame.outliers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": pandas.core.frame.DataFrame"}, {"fullname": "outlier_detection.base.DetectionFullDataFrame.without_outliers", "modulename": "outlier_detection.base", "qualname": "DetectionFullDataFrame.without_outliers", "kind": "variable", "doc": "<p></p>\n", "annotation": ": pandas.core.frame.DataFrame"}, {"fullname": "outlier_detection.base.DetectionPaired", "modulename": "outlier_detection.base", "qualname": "DetectionPaired", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "Detection"}, {"fullname": "outlier_detection.base.DetectionPaired.diagram", "modulename": "outlier_detection.base", "qualname": "DetectionPaired.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.columns", "modulename": "outlier_detection.columns", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.columns.NAME_DATA", "modulename": "outlier_detection.columns", "qualname": "NAME_DATA", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;data&#x27;"}, {"fullname": "outlier_detection.columns.NAME_OTHER", "modulename": "outlier_detection.columns", "qualname": "NAME_OTHER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;data_other&#x27;"}, {"fullname": "outlier_detection.columns.NAME_MEAN", "modulename": "outlier_detection.columns", "qualname": "NAME_MEAN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;mean&#x27;"}, {"fullname": "outlier_detection.columns.NAME_STD_DEV", "modulename": "outlier_detection.columns", "qualname": "NAME_STD_DEV", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;stv_dev&#x27;"}, {"fullname": "outlier_detection.columns.NAME_IS_OUTLIER", "modulename": "outlier_detection.columns", "qualname": "NAME_IS_OUTLIER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;is_outlier&#x27;"}, {"fullname": "outlier_detection.columns.NAME_MEDIAN", "modulename": "outlier_detection.columns", "qualname": "NAME_MEDIAN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;median&#x27;"}, {"fullname": "outlier_detection.columns.NAME_ABS_DIFF", "modulename": "outlier_detection.columns", "qualname": "NAME_ABS_DIFF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;abs_diff&#x27;"}, {"fullname": "outlier_detection.columns.NAME_SUM", "modulename": "outlier_detection.columns", "qualname": "NAME_SUM", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;sum&#x27;"}, {"fullname": "outlier_detection.columns.NAME_ID", "modulename": "outlier_detection.columns", "qualname": "NAME_ID", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;id&#x27;"}, {"fullname": "outlier_detection.columns.NAME_COUNT", "modulename": "outlier_detection.columns", "qualname": "NAME_COUNT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;count&#x27;"}, {"fullname": "outlier_detection.columns.NAME_PROBABILITY", "modulename": "outlier_detection.columns", "qualname": "NAME_PROBABILITY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;probability&#x27;"}, {"fullname": "outlier_detection.columns.NAME_CATEGORY", "modulename": "outlier_detection.columns", "qualname": "NAME_CATEGORY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;category&#x27;"}, {"fullname": "outlier_detection.columns.NAME_NUMERICAL", "modulename": "outlier_detection.columns", "qualname": "NAME_NUMERICAL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;numerical&#x27;"}, {"fullname": "outlier_detection.files", "modulename": "outlier_detection.files", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.files.categorial_x_categorial", "modulename": "outlier_detection.files", "qualname": "categorial_x_categorial", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple", "modulename": "outlier_detection.simple", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers", "modulename": "outlier_detection.simple.multidimensional_outliers", "kind": "module", "doc": "<p>Wissenswertes zur Darstellung von zwei Spalten vom Typ Zahl oder Kategorie:</p>\n\n<ul>\n<li>Zahl und Zahl, als Darstellung wird ein Scatterplatt verwendet</li>\n<li>Kategorie und Zahl, als Darstellung wird ein Boxplot verwendet.\nAlle Zahlen-Punkte au\u00dferhalb der Boxen sind Ausrei\u00dfer.</li>\n<li>Kategorie und Kategorie, als Darstellung werden die Kombinationen der beiden Kategorien gez\u00e4hlt\nund daraus eine Heatmap erstellt.</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "kind": "module", "doc": "<p>Categorical X Categorial: Outlier-Detection f\u00fcr zwei Categorial Spalten mittels Randwahrscheinlichkeit.</p>\n\n<p>Findet Ausrei\u00dfer in 2-Dimensionalen kategorischen Daten.\nDie Daten k\u00f6nnen beliebigen Typ haben, egal ob int oder str.\nEs werden komplette Kategorien als Ausrei\u00dfer entfernt.</p>\n\n<p>Die Tabelle wird umgewandelt in Hilfstabellen. Diese hat als Zeilen eine Kategorie und als Index die andere Kategorie.\nDadurch werden alle Kombinationen abgebildet.</p>\n\n<p>Funktionsweise:</p>\n\n<ol>\n<li>Z\u00e4hlt erst die Anzahl der Datens\u00e4tze jeder vorhanden Kategorie-Kombination.</li>\n<li>Ermittel f\u00fcr jede Kombination die Eintrittswahrscheinlichkeit bzw. Erwartungswert mit der Formel:\n(Summe(Kategorie in Spalte) / Datensatz_gesamt) * (Summe(Kategorie in Zeile) / Datensatz_gesamt) * Datensatz_gesamt</li>\n<li>Ermittel die Abweichung vom Erwartungswert:\nTeile paarweise Matrix aus 1. durch Matrix aus 2.</li>\n<li>Pr\u00fcfe den Grenzwert der Matrix 1. mit der Anzahl der Datens\u00e4tze\nund den Grenzwert der Matrix 3. mit der Abweichung vom Erwartungswert.\nLiegt eine Kategorie-Kombination unter <strong>beiden</strong> Grenzwerten handelt es sich um einen Ausrei\u00dfer.</li>\n</ol>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.NAME_CUM_SUM", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "NAME_CUM_SUM", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;cum_sum&#x27;"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.logger", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial", "kind": "class", "doc": "<p>Categorical X Categorial: Outlier-Detection f\u00fcr zwei Categorial Spalten mittels Randwahrscheinlichkeit.</p>\n\n<p>Diese Klasse erweitert die DetectionPaired-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern basierend auf der Berechnung der Randwahrscheinlichkeit\nsowie zur Visualisierung der Ergebnisse.\nDie beiden Grenzwerte werden an den Konstruktor \u00fcbergeben.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_CUM_SUM : str\nName der Spalte, in der die berechneten Cumulative Summe gespeichert wird.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>NAME_SUM : str\nName der Spalten und Zeilensummen in den Hilfstabellen, bei der ausgabe \u00fcber die Methode *print_sum_df(df)*</li>\n<li>NAME_COUNT : str\nName der Spalte, in der die Anzahl der Kategorie-Kombination steht</li>\n<li>NAME_PROBABILITY : str\nName der Spalte, f\u00fcr die Abweichung vom Erwartungswert <strong>nicht des Erwartungswertes!</strong></li>\n<li>data_count : DataFrame\nHilfstabelle mit der Anzahl der Kategorie-Kombinationen.</li>\n<li>data_prob : DataFrame\nHilfstabelle mit dem Erwartungswert der Kategorie-Kombinationen.</li>\n<li>data_expect : DataFrame\nHilfstabelle mit der Abweichung vom Erwartungswert der Kategorie-Kombination.\n(Tats\u00e4chliche Eintrittswahrscheinlichkeit)</li>\n<li>threshold_count : int\nGrenzwert f\u00fcr die Hilfstabelle *data_count*. Bei Unterschreitung ist es ein Ausrei\u00dfer.</li>\n<li>threshold_expectation : float\nGrenzwert f\u00fcr die Hilfstabelle *data_expectation*. Bei Unterschreitung ist es ein Ausrei\u00dfer.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>print_sum_df(df: pd.DataFrame)\nDas \u00fcbergebene DataFrame wird um alle Zeilen und Spalten Summen sowie die Gesamtsumme erg\u00e4nzt.\nVer\u00e4ndert das Dataframe nicht. Hat keinen R\u00fcckgabewert, f\u00fchrt nur den <em>print(df)</em> aus.</li>\n<li>marginal_probabilities()\nBerechnet Randwahrscheinlichkeit f\u00fcr die Daten, identifiziert seltene Werte\nals Ausrei\u00dfer basierend auf den gegebenen Thresholds: *threshold_count* und <em>threshold_expectation</em>\nund markiert diese.</li>\n<li>_build_data_count(vc: DataFrame)\nErstellt die Hilfstabelle *data_count*. Ben\u00f6tigt als Parameter die Matrix mit den\ngez\u00e4hlten Kategorie-Kombinationen. (vc = df.value_counts([A, B])</li>\n<li>_build_data_prob(vc: DataFrame)\nErstellt die Hilfstabelle *data_prob*. Ben\u00f6tigt als Parameter die Matrix mit den\ngez\u00e4hlten Kategorie-Kombinationen. (vc = df.value_counts([A, B])</li>\n<li>_build_data_expect(vc: DataFrame)\nErstellt die Hilfstabelle *data_expect*. Ben\u00f6tigt als Parameter die Matrix mit den\ngez\u00e4hlten Kategorie-Kombinationen. (vc = df.value_counts([A, B])</li>\n<li>diagram()\nVisualisiert die Datenverteilung mit zwei HeatMaps. Die erste basiert auf der Anzahl,\ndie zweite auf der Abweichung vom Erwartungswert.\nHebt die unterschreitung der Grenzwerte hervor.\nAusrei\u00dfer sind alle die in beiden F\u00e4llen die Grenzwerte unterschreiten.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of str\nDie zu pr\u00fcfenden Datenpunkte der einen Kategorie.</li>\n<li>other_data : list of str\nDie zu pr\u00fcfenden Datenpunkte der anderen Kategorie.</li>\n<li>threshold_count : int, optional\nGrenzwert f\u00fcr Ausrei\u00dfer der Hilfstabelle *data_count* (Standard: 1000,\nmuss von Hand nach Pr\u00fcfung der Daten gesetzt werden).</li>\n<li>threshold_expectation Grenzwert f\u00fcr die Hilfstabelle *data_expectation*. (Standard: 0.5,\nWert sollte deutlich unter 1.0 liegen)</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>cxc = CategorialXCategorial([\"A\", \"B\", \"C\"], [\"X\", \"Y\", \"Z\"], threshold_count=1000, threshold_expectation=0.5)\ncxc.marginal_probabilities()\ncxc.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.DetectionPaired"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.__init__", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">other_data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_count</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">threshold_expectation</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span></span>)</span>"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.threshold_count", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.threshold_count", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.threshold_expectation", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.threshold_expectation", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.data_count", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.data_count", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.data_prob", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.data_prob", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.data_expect", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.data_expect", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.print_sum_df", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.print_sum_df", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.marginal_probabilities", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.marginal_probabilities", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial.CategorialXCategorial.diagram", "modulename": "outlier_detection.simple.multidimensional_outliers.categorial_x_categorial", "qualname": "CategorialXCategorial.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "kind": "module", "doc": "<p>Numerical X Numerical: Outlier-Detection f\u00fcr ein DataFrame mittels MAD-Summe.</p>\n\n<p>Findet Ausrei\u00dfer im kompletten DataFrame aus numerischen Daten.\nAlle Daten m\u00fcssen vom Typ <em>float</em> oder <em>int</em> sein.\nBerechnet sie MAD-Summe je Zeile. Entsprechend werden komplette Zeilen als Ausrei\u00dfer entfernt.</p>\n\n<p>Funktionsweise:</p>\n\n<ol>\n<li>Der MAD-Score von jeder Spalte wird berechnet.</li>\n<li>Alle MAD-Scores werden je Spalte mit dem MinMaxScaler auf Werte zwischen 0.0 und 1.0 normalisiert.</li>\n<li>Die Zeilen-Summe aller normalisierten MAD-Werte wird gebildet.</li>\n<li>Pr\u00fcfe den Grenzwert auf die Zeilen-Summe. Ausrei\u00dfer sind alle Werte die gr\u00f6\u00dfer als der Grenzwert sind.</li>\n</ol>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NAME_MAD_SUM", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NAME_MAD_SUM", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;mad_sum&#x27;"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame", "kind": "class", "doc": "<p>NumericalFullDataFrame: Outlier-Detection f\u00fcr ein DataFrame mittels MAD-Summe.</p>\n\n<p>Diese Klasse erweitert die DetectionFullDataFrame-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern basierend auf der Berechnung der MAD-Summen\nsowie zur Visualisierung der Ergebnisse.\nEs gibt keine Visualisierung der Originaldaten.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_MAD_<i> : str\nName der Spalte, in der die normalisierten absoluten Abweichungen gespeichert werden.</li>\n<li>NAME_MAD_SUM : str\nName der Spalte, in der die Zeilensumme der MAD-Werte steht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>threshold : float\nGrenzwert f\u00fcr die MAD-Summen. Bei \u00dcberschreitung ist es ein Ausrei\u00dfer.\nDer Wert muss von Hand gesetzt werden, vorher Daten analysieren!</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>_calc_mad(values: list[float])\nBerechnet den MAD-Score f\u00fcr eine \u00fcbergebene Spalte. Gibt die Ergebnisspalte zur\u00fcck.\nDas Format ist jeweils <em>list</em>.</li>\n<li>mad_sum()\nBerechnet die MAD-Summen f\u00fcr die Daten, identifiziert\nals Ausrei\u00dfer basierend auf den gegebenen Grenzwert: <em>threshold</em>\nund markiert diese.</li>\n<li>_build_data_count(vc: DataFrame)\nErstellt die Hilfstabelle *data_count*. Ben\u00f6tigt als Parameter die Matrix mit den\ngez\u00e4hlten Kategorie-Kombinationen. (vc = df.value_counts([A, B])</li>\n<li>_build_data_prob(vc: DataFrame)\nErstellt die Hilfstabelle *data_prob*. Ben\u00f6tigt als Parameter die Matrix mit den\ngez\u00e4hlten Kategorie-Kombinationen. (vc = df.value_counts([A, B])</li>\n<li>_build_data_expect(vc: DataFrame)\nErstellt die Hilfstabelle *data_expect*. Ben\u00f6tigt als Parameter die Matrix mit den\ngez\u00e4hlten Kategorie-Kombinationen. (vc = df.value_counts([A, B])</li>\n<li>diagram()\nVisualisiert die MAD-Verteilung als Histogramm und zeigt den\nSchwellenwert f\u00fcr Ausrei\u00dfer als vertikale Linie an. DIe Originaldaten werden nicht visualisiert.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : pd.DataFrame\nDie zu pr\u00fcfenden Datenpunkte, sie m\u00fcssen alle vom Typ <em>int</em> oder <em>float</em> sein.</li>\n<li>threshold : float, optional\nGrenzwert f\u00fcr die MAD-Summen. Bei \u00dcberschreitung ist es ein Ausrei\u00dfer.\nDer Wert muss von Hand gesetzt werden, vorher Daten analysieren! (Standard: 8.0)</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>cxc = CategorialXCategorial([\"A\", \"B\", \"C\"], [\"X\", \"Y\", \"Z\"], threshold_count=1000, threshold_expectation=0.5)\ncxc.marginal_probabilities()\ncxc.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.DetectionFullDataFrame"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame.__init__", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">8.0</span></span>)</span>"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame.data", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame.data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame.mad_scores", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame.mad_scores", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame.threshold", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame.mad_sum", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame.mad_sum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical.NumericalFullDataFrame.diagram", "modulename": "outlier_detection.simple.multidimensional_outliers.numerical_x_numerical", "qualname": "NumericalFullDataFrame.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_categorial", "modulename": "outlier_detection.simple.one_dimension_categorial", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "kind": "module", "doc": "<p>1D-Categorical: Outlier-Detection mittels Cumulative Summe.</p>\n\n<p>Findet Ausrei\u00dfer in 1-Dimensionalen kategorischen Daten.\nDie Daten k\u00f6nnen beliebigen Typ haben, egal ob int oder str.\nEs werden komplette Kategorien als Ausrei\u00dfer entfernt.</p>\n\n<p>Funktionsweise</p>\n\n<ol>\n<li>Z\u00e4hlt erst die Anzahl der Datens\u00e4tze jeder Kategorie.</li>\n<li>Bildet dann die Prozentuale cumulative Summe. D.h. die Anteile aller Datens\u00e4tze werden bus 1.0 aufsummiert.</li>\n<li>Wendet den Grenzwert auf die Summe an. Entfernt dabei jeweils komplette Kategorien.</li>\n</ol>\n"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.NAME_CUM_SUM", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "NAME_CUM_SUM", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;cum_sum&#x27;"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.logger", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.OneDimCategorial", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "OneDimCategorial", "kind": "class", "doc": "<p>1D-Categorical: Outlier-Detection mittels Cumulative Summe.</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern basierend auf der Berechnung der cumulativen Summe\nsowie zur Visualisierung der Ergebnisse.\nDer Grenzwert wird an den Konstruktor \u00fcbergeben.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_CUM_SUM : str\nName der Spalte, in der die berechneten Cumulative Summe gespeichert wird.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>cumm_frac: DataFrame\nEnth\u00e4lt die Daten mit zugeh\u00f6riger cumulative Summe.</li>\n<li>threshold: float\nDer Grenzwert ab wann es ein Ausrei\u00dfer ist.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>cum_sum()\nBerechnet cumultative Summe f\u00fcr die Daten, identifiziert seltene Werte\nals Ausrei\u00dfer basierend auf dem gegebenen Threshold und markiert diese.</li>\n<li>diagram()\nVisualisiert die Datenverteilung als Histogramm und hebt die identifizierten\nAusrei\u00dfer als vertikale Linien hervor.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>threshold : float, optional\nGrenzwert f\u00fcr Ausrei\u00dfer (Standard: 0.5, m\u00f6glich ist auch 1.0).</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>odc = OneDimCategorial(data=[1, 2, 2, 3, 100, 101], threshold=0.5)\nodc.cum_sum()\nodc.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.OneDimCategorial.__init__", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "OneDimCategorial.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.05</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.OneDimCategorial.threshold", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "OneDimCategorial.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.OneDimCategorial.cumm_frac", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "OneDimCategorial.cumm_frac", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.OneDimCategorial.cum_sum", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "OneDimCategorial.cum_sum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial.OneDimCategorial.diagram", "modulename": "outlier_detection.simple.one_dimension_categorial.one_dimension_categorial", "qualname": "OneDimCategorial.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric", "modulename": "outlier_detection.simple.one_dimension_numeric", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "kind": "module", "doc": "<p>Histogram Binning \u2013 Erkl\u00e4rung</p>\n\n<p>Histogram Binning bezeichnet den Prozess, numerische Daten in diskrete Intervalle\n(Bins) einzuteilen, um ihre Verteilung sichtbar oder analysierbar zu machen.\nJeder Bin repr\u00e4sentiert dabei einen Wertebereich und z\u00e4hlt, wie viele Datenpunkte\ninnerhalb dieses Bereichs liegen.</p>\n\n<p>Das Verfahren ist grundlegend f\u00fcr Histogramme, Diskretisierung von Daten und viele\nvorbereitende Schritte in der Datenanalyse oder beim maschinellen Lernen.</p>\n\n<p>Grundprinzip:</p>\n\n<ol>\n<li>Gesamtbereich der Daten bestimmen (min bis max).</li>\n<li>Diesen Bereich in eine feste Anzahl gleich gro\u00dfer Bins unterteilen\noder die Binbreite basierend auf einer Regel berechnen.</li>\n<li>F\u00fcr jeden Datenpunkt bestimmen, in welchen Bin er f\u00e4llt.</li>\n<li>Die Anzahl der Punkte pro Bin z\u00e4hlen.</li>\n<li>Sind in einem Bin weniger Punkte als es Bins gibt (Standard 10 Bins), handelt es sich um Ausrei\u00dfer</li>\n</ol>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram.Histogram", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "qualname": "Histogram", "kind": "class", "doc": "<p>Histogram: Outlier-Detection mittels Histogramm-Binning</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern basierend auf selten besetzten Histogramm-Bins\nsowie zur Visualisierung der Ergebnisse.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>bins : int\nAnzahl der Bins, die f\u00fcr die Histogrammberechnung verwendet werden.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>histogram()\nBerechnet die Histogramm-Bins f\u00fcr die Daten und markiert alle Werte\nin selten besetzten Bins (weniger als <code>_bins</code> Elemente) als Ausrei\u00dfer.</li>\n<li>diagram()\nVisualisiert die Datenverteilung als Histogramm und hebt die identifizierten\nAusrei\u00dfer als vertikale Linien hervor.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>bins : int, optional\nAnzahl der Histogramm-Bins (Standard: 10).</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>h = Histogram(data=[1, 2, 2, 3, 100, 101], bins=5)\nh.histogram()\nh.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram.Histogram.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "qualname": "Histogram.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">bins</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram.Histogram.bins", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "qualname": "Histogram.bins", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram.Histogram.histogram", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "qualname": "Histogram.histogram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.histogram.Histogram.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.histogram", "qualname": "Histogram.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "kind": "module", "doc": "<h1 id=\"idr-interdecile-range\">IDR \u2013 Interdecile Range</h1>\n\n<p>Der Interdezilenabstand (IDR) ist ein robustes Streuungsma\u00df und beschreibt\nden Wertebereich, in dem die mittleren 80 % der Daten liegen. Er wird als\nDifferenz zwischen dem 90. Perzentil (D9) und dem 10. Perzentil (D1) berechnet.</p>\n\n<p>Damit ist der IDR deutlich weniger anf\u00e4llig f\u00fcr Ausrei\u00dfer als z. B.\ndie Standardabweichung, aber empfindlicher als der IQR.</p>\n\n<p>Berechnung:</p>\n\n<ol>\n<li>10%-Perzentil (D1) bestimmen.</li>\n<li>90%-Perzentil (D9) bestimmen.</li>\n<li>Differenz bilden:\nIDR = D9 - D1</li>\n</ol>\n\n<p>Interpretation:</p>\n\n<ul>\n<li>Kleiner IDR: Die zentralen 80 % der Daten liegen eng zusammen.</li>\n<li>Gro\u00dfer IDR: H\u00f6here Streuung im Hauptdatenbereich.</li>\n<li>Da 10 % der kleinsten und 10 % der gr\u00f6\u00dften Werte ignoriert werden,\nbietet der IDR einen guten Kompromiss zwischen Robustheit und Sensitivit\u00e4t.</li>\n</ul>\n\n<p>Ausrei\u00dfererkennung (klassische Tukey-Regel):</p>\n\n<ul>\n<li>Untere Grenze: Q1 - 1.0 * IDR</li>\n<li>Obere Grenze: Q3 + 1.0 * IDR\nWerte au\u00dferhalb dieses Bereichs gelten typischerweise als Ausrei\u00dfer.</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR", "kind": "class", "doc": "<p>IDR: Outlier-Detection mittels Interdecile Range</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern auf Basis des Interdecile Range (IDR)\nsowie zur Visualisierung der Ergebnisse.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>iqr_lower_limit : float\nUntere Grenze f\u00fcr Ausrei\u00dfer basierend auf dem IDR.</li>\n<li>iqr_upper_limit : float\nObere Grenze f\u00fcr Ausrei\u00dfer basierend auf dem IDR.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>idr()\nBerechnet den Interdecile Range (IDR) f\u00fcr die Daten und markiert alle\nWerte als Ausrei\u00dfer, die au\u00dferhalb des Bereichs [Q1 - threshold<em>IDR, Q9 + threshold</em>IDR] liegen.</li>\n<li>diagram()\nVisualisiert die Datenverteilung als Histogramm und zeigt die IDR-basierten\nAusrei\u00dfergrenzen als vertikale Linien an.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>threshold : float, optional\nMultiplikator f\u00fcr den IDR zur Definition der Ausrei\u00dfergrenzen\n(Standard: 1.0).</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>i = IDR(data=[1, 2, 3, 100], threshold=1.0)\ni.idr()\ni.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR.threshold", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR.iqr_lower_limit", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR.iqr_lower_limit", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR.iqr_upper_limit", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR.iqr_upper_limit", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR.idr", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR.idr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.idr.IDR.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.idr", "qualname": "IDR.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "kind": "module", "doc": "<h1 id=\"iqr-interquartile-range\">IQR \u2013 Interquartile Range</h1>\n\n<p>Der Interquartilsabstand (IQR) ist ein robustes Ma\u00df f\u00fcr die Streuung von Daten.\nEr beschreibt den Bereich, in dem die mittleren 50 % der Werte liegen, und ist daher\nweniger anf\u00e4llig f\u00fcr Ausrei\u00dfer als die Standardabweichung.</p>\n\n<p>Berechnung:</p>\n\n<ol>\n<li>Unteres Quartil (Q1, 25%-Perzentil) bestimmen.</li>\n<li>Oberes Quartil (Q3, 75%-Perzentil) bestimmen.</li>\n<li>Differenz bilden:\nIQR = Q3 - Q1</li>\n</ol>\n\n<p>Interpretation:</p>\n\n<ul>\n<li>Kleiner IQR: Die mittleren 50 % der Daten liegen dicht beieinander.</li>\n<li>Gro\u00dfer IQR: Hohe Streuung im zentralen Datenbereich.</li>\n<li>Der IQR eignet sich besonders gut zur Erkennung von Ausrei\u00dfern,\nda er auf Quartilen basiert und somit robust gegen\u00fcber Extremwerten ist.</li>\n</ul>\n\n<p>Ausrei\u00dfererkennung (klassische Tukey-Regel):</p>\n\n<ul>\n<li>Untere Grenze: Q1 - 2.2 (oder 1.5) * IQR</li>\n<li>Obere Grenze: Q3 + 2.2 (oder 1.5) * IQR\nWerte au\u00dferhalb dieses Bereichs gelten typischerweise als Ausrei\u00dfer.</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR", "kind": "class", "doc": "<p>IQR: Outlier-Detection mittels Interquartilsabstand</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern auf Basis des Interquartilsabstands (IQR)\nsowie zur Visualisierung der Ergebnisse.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>iqr_lower_limit : float\nUntere Grenze f\u00fcr Ausrei\u00dfer basierend auf dem IQR.</li>\n<li>iqr_upper_limit : float\nObere Grenze f\u00fcr Ausrei\u00dfer basierend auf dem IQR.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>iqr()\nBerechnet den IQR f\u00fcr die Daten und markiert alle Werte als Ausrei\u00dfer,\ndie au\u00dferhalb des Bereichs [Q1 - threshold<em>IQR, Q3 + threshold</em>IQR] liegen.</li>\n<li>diagram()\nVisualisiert die Datenverteilung als Histogramm und zeigt die IQR-basierten\nAusrei\u00dfergrenzen als vertikale Linien an.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>threshold : float, optional\nMultiplikator f\u00fcr den IQR zur Definition der Ausrei\u00dfergrenzen\n(Standard: 2.2) Auch 1.5 m\u00f6glich.</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>i = IQR(data=[1, 2, 3, 100], threshold=2.2)\n&gt;&gt; i.iqr()\n&gt;&gt; i.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">2.2</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR.threshold", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR.iqr_lower_limit", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR.iqr_lower_limit", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR.iqr_upper_limit", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR.iqr_upper_limit", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR.iqr", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR.iqr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.iqr.IQR.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.iqr", "qualname": "IQR.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "kind": "module", "doc": "<p>KDE \u2013 Kernel Density Estimation (Kerndichtesch\u00e4tzung)</p>\n\n<p>Die Kerndichtesch\u00e4tzung (KDE) ist ein Verfahren, um aus diskreten Daten\neine glatte, kontinuierliche Sch\u00e4tzung der Wahrscheinlichkeitsdichtefunktion (PDF)\nzu erzeugen. Im Gegensatz zu Histogrammen basiert die KDE nicht auf festen Bins,\nsondern auf der \u00dcberlagerung glatter Kernel-Funktionen (z. B. Gau\u00df-Kerne).</p>\n\n<p>KDE liefert eine deutlich weichere und oft pr\u00e4zisere Darstellung der Verteilung\nals Histogramme, kann jedoch empfindlich auf Ausrei\u00dfer reagieren \u2013 je nach Kerntyp\nund Bandbreite.</p>\n\n<p>Funktionsweise:</p>\n\n<ol>\n<li>F\u00fcr jeden Datenpunkt wird eine Kernel-Funktion (\u201eGlocke\u201c) erzeugt.</li>\n<li>Diese Funktionen werden summiert und normalisiert.</li>\n<li>Die Gl\u00e4ttung wird durch die <strong>Bandbreite</strong> (Bandwidth, h) gesteuert:\nKleine Bandbreite  \u2192 viele Details, potenziell verrauscht\nGro\u00dfe Bandbreite   \u2192 starke Gl\u00e4ttung, Informationsverlust</li>\n</ol>\n\n<p>Einfluss von Ausrei\u00dfern:</p>\n\n<ul>\n<li>Ausrei\u00dfer erzeugen einen Kernel weit weg vom zentralen Datenbereich.</li>\n<li>Bei kleiner Bandbreite kann dies zu \u201eNebenwellen\u201c oder unerw\u00fcnschten Peaks f\u00fchren.</li>\n<li>Bei gro\u00dfer Bandbreite wird der Einfluss eines Ausrei\u00dfers stark verwischt.</li>\n<li>Robustere Alternativen:</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.NAME_KDE", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "NAME_KDE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;kde&#x27;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.KDE", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "KDE", "kind": "class", "doc": "<p>KDE: Outlier-Detection mittels Kernel Density Estimation</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nIdentifikation von Ausrei\u00dfern basierend auf einer Kernel Density Estimation (KDE)\nsowie zur Visualisierung der Ergebnisse.\nVerwendet zur Ermittlung der Grenzwerte IQR.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>NAME_KDE : str\nName der Spalte, in der die berechneten KDE-Werte gespeichert werden.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>kde()\nBerechnet die Kernel Density f\u00fcr die Daten, identifiziert seltene Werte\nals Ausrei\u00dfer basierend auf IQR der KDE-Scores und markiert diese.</li>\n<li>diagram()\nVisualisiert die Datenverteilung als Histogramm und hebt die identifizierten\nAusrei\u00dfer als vertikale Linien hervor.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>bandwidth : float, optional\nBandbreite f\u00fcr die KDE-Berechnung (Standard: 0.2).</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>k = KDE(data=[1, 2, 2, 3, 100, 101], bandwidth=0.3)\nk.kde()\nk.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.KDE.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "KDE.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">bandwidth</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.KDE.bandwidth", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "KDE.bandwidth", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.KDE.kde", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "KDE.kde", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.kde.KDE.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.kde", "qualname": "KDE.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "kind": "module", "doc": "<p>KNN \u2013 k-Nearest-Neighbors Outlier Detection</p>\n\n<p>KNN ist ein Verfahren zur Identifikation von Ausrei\u00dfern basierend auf\nden Abst\u00e4nden zu den k-n\u00e4chsten Nachbarn eines jeden Datenpunkts.\nDie Grundidee: Punkte, die weit von ihren Nachbarn entfernt sind, gelten\nals potenzielle Ausrei\u00dfer. Wenn die Entfernung der Punkte erst abnimmt bis 0 und dann wieder\nzunimmt, bildet sich ein 'Schwanz'. Der Kennzeichnet den Grenzwert der <strong>visuel</strong> aus\ndem Histogram ermittelt werden muss.</p>\n\n<p>Berechnung:</p>\n\n<ol>\n<li>F\u00fcr jeden Datenpunkt die Abst\u00e4nde zu seinen k n\u00e4chsten Nachbarn berechnen.</li>\n<li>Den maximalen Abstand zu den k Nachbarn bestimmen (max_dist).</li>\n<li>Einen Schwellenwert festlegen; Punkte mit max_dist &gt; threshold werden\nals Ausrei\u00dfer markiert.</li>\n</ol>\n\n<p>Formel:\n    max_dist_i = max(Distanz(x_i, x_j) f\u00fcr j in k-Nachbarn von i)</p>\n\n<p>Bedeutungen:</p>\n\n<ul>\n<li>Kleiner max_dist: Punkt liegt nah an seinen Nachbarn \u2192 typischer Datenpunkt.</li>\n<li>Gro\u00dfer max_dist: Punkt liegt weit entfernt \u2192 potenzieller Ausrei\u00dfer.</li>\n<li>Der Ansatz ist besonders geeignet f\u00fcr Daten ohne feste Verteilungsannahmen.</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.NAME_KNN", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "NAME_KNN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;knn&#x27;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN", "kind": "class", "doc": "<p>KNN: Outlier-Detection mittels k-Nearest-Neighbors</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nBerechnung von Ausrei\u00dfern basierend auf den Abst\u00e4nden zu den k-n\u00e4chsten\nNachbarn (k-Nearest-Neighbors, KNN) sowie zur Visualisierung der Ergebnisse.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>NAME_KNN : str\nName der Spalte, in der die maximalen Distanzen zu den k n\u00e4chsten Nachbarn gespeichert werden.</li>\n<li>k : int\nAnzahl der Nachbarn, die f\u00fcr die Berechnung der KNN-Distanzen verwendet werden.</li>\n<li>threshold : float\nSchwellenwert f\u00fcr die Ausrei\u00dfererkennung basierend auf den maximalen Nachbarabst\u00e4nden.</li>\n<li>max_dist_arr : array-like\nSpeichert die maximalen Distanzen zu den k n\u00e4chsten Nachbarn.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>knn()\nBerechnet f\u00fcr alle Werte in <code>data</code> die maximalen Abst\u00e4nde zu den k\nn\u00e4chsten Nachbarn und markiert Werte als Ausrei\u00dfer, die den Schwellenwert \u00fcberschreiten.</li>\n<li>diagram()\nVisualisiert die Verteilung der KNN-Abst\u00e4nde als Histogramm und zeigt\nden Schwellenwert f\u00fcr Ausrei\u00dfer als vertikale Linie an.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>k : int, optional\nAnzahl der n\u00e4chsten Nachbarn, die f\u00fcr die Berechnung verwendet werden (Standard: 25).</li>\n<li>threshold : float, optional\nSchwellenwert f\u00fcr die Ausrei\u00dfererkennung (Standard: 0.2).</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>k = KNN(data=[1, 2, 3, 100], k=3, threshold=0.5)\nk.knn()\nk.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">25</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN.k", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN.k", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN.threshold", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN.max_dist_arr", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN.max_dist_arr", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN.knn", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN.knn", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.knn.KNN.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.knn", "qualname": "KNN.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "kind": "module", "doc": "<h1 id=\"mad-median-absolute-deviation\">MAD \u2013 Median Absolute Deviation</h1>\n\n<p>Der MAD ist ein robustes Streuungsma\u00df, das beschreibt,\nwie stark die Werte einer Verteilung typischerweise vom Median abweichen.\nIm Gegensatz zur Standardabweichung ist der MAD unempfindlicher gegen\u00fcber Ausrei\u00dfern.</p>\n\n<p>Berechnung:</p>\n\n<ol>\n<li>Median der Daten bestimmen.</li>\n<li>F\u00fcr jeden Wert die absolute Abweichung vom Median berechnen:\n|x_i - median|</li>\n<li>Median dieser absoluten Abweichungen berechnen:\nmedian(|x_i - median|).</li>\n<li>Den MAD-Score berechnen: |x_i - median| / median(|x_i - median|)</li>\n</ol>\n\n<p>Formel:\n    MAD = |x_i - median| / median(|x_i - median|)</p>\n\n<p>Bedeutungen:</p>\n\n<ul>\n<li>Kleiner MAD: Die Daten liegen eng um den Median.</li>\n<li>Gro\u00dfer MAD: Starke Streuung bzw. gr\u00f6\u00dfere Variabilit\u00e4t der Werte.</li>\n<li>Da der MAD robust ist, eignet er sich gut zur Ausrei\u00dfererkennung.</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.NAME_MAD", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "NAME_MAD", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;mad&#x27;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.NAME_MEDIAN_ABS_DIFF", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "NAME_MEDIAN_ABS_DIFF", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;median_abs_diff&#x27;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.MAD", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "MAD", "kind": "class", "doc": "<p>MAD: Outlier-Detection mittels Median Absolute Deviation</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nBerechnung der Median Absolute Deviation (MAD) und zur Visualisierung\nder Ergebnisse.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>NAME_MAD : str\nName der Spalte, in der die normalisierten absoluten Abweichungen gespeichert werden.</li>\n<li>NAME_MEDIAN: str\nName der Spalte, in der der Median der Werte gespeichert wird.</li>\n<li>NAME_ABS_DIFF: str\nName der Spalte, in der die positive Differenz der Werte und des Median (absolute Abweichung)\ngespeichert sind.</li>\n<li>NAME_MEDIAN_ABS_DIFF : str\nName der Spalte, die die Median der absoluten Abweichungen enth\u00e4lt.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>mad()\nBerechnet f\u00fcr alle Werte in <code>data</code> die MAD und markiert Werte als\nAusrei\u00dfer, die den Schwellenwert \u00fcberschreiten.</li>\n<li>diagram()\nVisualisiert die MAD-Verteilung als Histogramm und zeigt den\nSchwellenwert f\u00fcr Ausrei\u00dfer als vertikale Linie an.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>threshold : float, optional\nSchwellenwert f\u00fcr die Ausrei\u00dfererkennung (Standard: 4.0).</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>m = MAD(data=[1, 2, 3, 100], threshold=3.5)\nm.mad()\nm.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.MAD.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "MAD.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">4.0</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.MAD.threshold", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "MAD.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.MAD.mad", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "MAD.mad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.mad.MAD.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.mad", "qualname": "MAD.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "kind": "module", "doc": "<h1 id=\"z-score\">Z-Score</h1>\n\n<p>Der Z-Score ist eine standardisierte Kennzahl, die beschreibt,\nwie viele Standardabweichungen ein Wert x vom Mittelwert \u00b5\neiner Verteilung entfernt ist.</p>\n\n<p>Formel:\n    z = (x - \u00b5) / \u03c3</p>\n\n<p>Bedeutungen:</p>\n\n<ul>\n<li>z = 0: Wert liegt exakt auf dem Mittelwert.</li>\n<li>z &gt; 0: Wert liegt \u00fcber dem Mittelwert.</li>\n<li>z &lt; 0: Wert liegt unter dem Mittelwert.</li>\n<li>|z| &gt;= 2 oder 3: H\u00e4ufiges Kriterium zur Erkennung von Ausrei\u00dfern.</li>\n</ul>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.logger", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.NAME_Z_SCORE", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "NAME_Z_SCORE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;z-score&#x27;"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.Z_SCORE", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "Z_SCORE", "kind": "class", "doc": "<p>Z_SCORE: Outlier-Detection mittels Z-Score</p>\n\n<p>Diese Klasse erweitert die Detection-Klasse und bietet Methoden zur\nBerechnung des Z-Scores und zur Visualisierung der Ergebnisse.</p>\n\n<h2 id=\"eigenschaften-konstanten\">Eigenschaften / Konstanten</h2>\n\n<ul>\n<li>NAME_DATA: str\nName der Spalten, die die Kategorien enth\u00e4lt. Sie wird auf Ausrei\u00dfer untersucht.</li>\n<li>NAME_IS_OUTLIER : str\nName der Spalte, ist es ein Ausrei\u00dfer?</li>\n<li>NAME_Z_SCORE : str\nName der Spalte, in der die berechneten Z-Scores gespeichert werden.</li>\n<li>NAME_MEAN : str\nName der Spalte, die den Mittelwert berechnet.</li>\n<li>NAME_STD_DEV : str\nName der Spalte, die die Standardabweichung berechnet.</li>\n</ul>\n\n<h6 id=\"methoden\">Methoden</h6>\n\n<ul>\n<li>z_score()\nBerechnet f\u00fcr alle Werte in <code>data</code> den Z-Score und markiert Werte\nals Ausrei\u00dfer, die au\u00dferhalb des Bereichs [-threshold, threshold] liegen.</li>\n<li>diagram()\nVisualisiert die Z-Score-Verteilung als Histogramm und zeigt die\nSchwellenwerte f\u00fcr Ausrei\u00dfer als vertikale Linien an.</li>\n</ul>\n\n<h6 id=\"parameter\">Parameter</h6>\n\n<ul>\n<li>data : list of int or float\nDie zu pr\u00fcfenden Datenpunkte.</li>\n<li>threshold : float, optional\nSchwellenwert f\u00fcr die Ausrei\u00dfererkennung (Standard: 3.0).</li>\n</ul>\n\n<h6 id=\"varianten\">Varianten</h6>\n\n<ul>\n<li>Die minimalen und maximalen 1 % der Daten vorher abschneiden.</li>\n<li>Den Algorithmus iterativ, ausf\u00fchren. Nach dem Entfernen eines Outliers, \u00e4ndern sich die Parameter\nf\u00fcr eine erneute Berechnung. Dadurch werden andere Outliers gefunden.</li>\n</ul>\n\n<h6 id=\"beispiel\">Beispiel</h6>\n\n<pre><code>z = Z_SCORE(data=[1, 2, 3, 100], threshold=2.5)\nz.z_score()\nz.diagram()\n</code></pre>\n", "bases": "outlier_detection.base.Detection"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.Z_SCORE.__init__", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "Z_SCORE.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span>)</span>"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.Z_SCORE.threshold", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "Z_SCORE.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.Z_SCORE.z_score", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "Z_SCORE.z_score", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.simple.one_dimension_numeric.z_score.Z_SCORE.diagram", "modulename": "outlier_detection.simple.one_dimension_numeric.z_score", "qualname": "Z_SCORE.diagram", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.utils", "modulename": "outlier_detection.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "outlier_detection.utils.logger", "modulename": "outlier_detection.utils", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;loguru.logger handlers=[(id=0, level=10, sink=&lt;_io.TextIOWrapper encoding=&#x27;UTF-8&#x27;&gt;)]&gt;"}, {"fullname": "outlier_detection.utils.abs_diff", "modulename": "outlier_detection.utils", "qualname": "abs_diff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">in_col_x</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">in_col_y</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.utils.mean", "modulename": "outlier_detection.utils", "qualname": "mean", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">in_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.utils.median", "modulename": "outlier_detection.utils", "qualname": "median", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">in_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.utils.quantile", "modulename": "outlier_detection.utils", "qualname": "quantile", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">in_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "outlier_detection.utils.std_dev", "modulename": "outlier_detection.utils", "qualname": "std_dev", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">in_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_col</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();